# 
1. **Убрать из .gitignore composer.lock.** У зависимостей могут быть свои зависимости, которые не будут указаны в composer.json. К примеру, `"doctrine/dbal": "^4.1",` может возникнуть ситуация, когда у одного разрабочтика установится версия 4.3.3, а у другого 4.3.2. Конфликта в зависимостях не будет, но может повлиять на работоспособность приложения или другая версия установится непосредственно на рабочей среде, что не было протестировано/проверено, а это уже чревато болезненными ситуациями. В разработке бибилиотек можно не фиксировать composer.lock, а при создании проекта стоит. 
2. **Тип и комментарий к колонке name**. В файле migrations\schema.init.sql на строке 8 для колонки name указан тип text и значение по-умолчанию. Во-первых, для типа text нельзя указать значение по-умолчанию. BLOB и TEXT столбцы не могут содержать DEFAULT значений. Это указано в документации Mysql. Во-вторых, я думаю, что тип text тут избыточен. Если это наименование товара, то думаю достаточно типа varchar(255) и оставить default ''. Комментарий кажется несоответсвует столбцу. Скоорее всего это должно быть "Наименование товара" 
   >*Тут надо уточнить по предметной области, возможно для этого проекта и необходимо длинное название и тип text, но я исправлю, так как не встречала такой необходимости. Думаю, что и длины в 255 символов тоже много, но оставлю так* 
3. **Комментарий к колонке is_active**. Этот момент не обязательный. В файле migrations\schema.init.sql на строке 6. В целом, понятно, что это флаг активности и 1 = активно, а 0 = не активно. Но я для себя в комментариях указываю какие значения бывают и что значат. Со временем можно забыть и когда новые люди приходят на проект им будет быстрее влиться в работу. Поэтому изменю комментарий на "Флаг активности (1 - активно, 0 - не активно)"
4. **Переименование контроллеров, удаление readonly**. Как поняла, для каждого эндпоинта был создан свой контроллер. В таком случае у нас один класс - один метод. Зачем создавать класс в таком случае? Можно сделать функцию вместо класса. Потом, в классе AddToCartController метод get. Почему контроллер для добавления товара в корзину, а метод "получения". Предлагаю сделать отдельный контроллер для корзины - CartControlller, в котром реализовать методы getCart (получение корзины) и addToCart (добавление к корзине) и отдельный контроллер для товаров - ProductController. Также стоит убрать readonly. Мы же будем добавлять элементы в корзину, с товарами тоже могут поисходить манипуляции в контроллере.
5. **Не реализованы методы интерфейса в JsonResponse  и расположение**. Интерфейсы указывают нам методы, которые должны быть реализованы в классе. Созадла папку Response в src и перенесла этот класс туда. Не надо ему располагаться в разделе с контроллерами. перенесла код статуса и Content-Type в этот класс, чтобы не указывать их из контроллеров. Если сипользуем что-то дважды, значит делаем не эффективно, нужно убирать повторения. К тому же это же json response -> сразу надо делать под json.   
    >*В комментарии к классу указано что это заглушка. Сделала приблизительную реализацию методов. Есть компоненты и готовые решения. Этот класс можно перенести в другой раздел, для данной задачи оставлю так, потому что нет всей структуры проекта*
6. **Перенос сущностей Cart, CartItem, Customer, Product**. Перенесла классы сущностей в отдельную папку Entity ( она была ранее в Repository). Не поняла почему была папка Domain, я бы отнесла классы из нее к объектам/моделям. Также убрала readonly у paymentMethod в Cart и изменила облсть видимсти на ptivate в CartItem.
Потому что paymentMethod скорее всего подразумевает выбор способа оплаты и в корзине пользователь сможет изменить его, сейчас нет задачи по изменению свойств корзины, кроме изменения товаров, но на будущее надо учитывать. Классы final кроме класса товаров. Возможно в проекте потребуется наследование товаров и сейчас не критична эта опция. Пока можно оставить не final Product, но область видимости стоит заменить на private, чтобы были доступны только из методов классов. В целом, для final классов можно и protected указать, но это, на мой взгляд, можно не трогать. Пока оставлю так.
7. **Правки для эндпоинта по товарам**. Добавила уникальность для uuid в таблице товаров и убрала индекс на is_active. Сделала индекс на категорию. В запросе по категориям будет уместно, но при увеличении проекта, возможно индекс надо изменить. На самом деле, если у нас немного товаров, то возможно и индекс делать не имеет смысла. Не понятно почему категория - строка. Я бы выделила отдельную таблицу для категорий. Пример сделала комментарием в миграции. В этом случае придется делать связь товара и категории и менять запрос с JOIN category для получения товаров по категории. Сейчас это править не стала. Не понятно какие товары и категории, возможно достаточно будет enum без создания доп таблицы, а если категории имеют свою структуру (дерево с подкатегориями), тогда придется думать над архитектурой таблиц.  
Также при запросе получения товаров думаю лучше добавить order by, limit offset. Для упорядочевания товаров и если их очень много, то получать огромный список товаров не есть хорошо, в лучшем случае это будет немного долго. Поэтому стоит подумать над пагинацией. Добваила как пример. Но если использовать это, то тогда стоит добавить общее кол-во товаров, сколько таблиц и ккая текущая. Не понятно почему у нас is_active = 1 по-умолчанию. В ТЗ не скказано, что активные или не активные товары. Если это те, что можно .добавить в корзину - окей, если нет, то надо еще и получать инфу об этом.
В ProductsView вызывался метод получения товаров из бд. Убрала и перенесла в контроллер. Работа с данными в моделях, контроллеры для определения логики и взаимодействия, а отображение отдельно, без логики и обработки данных. Возможно имеет смысл перенести представление в виде массива в самом классе Product, но можно оставить и в View.  
Изменила ProductsView на ProductView - отображение 1 товара, а не нескольких.  
Сделала примерную обработку ошибок. Выводить информацию стоит единообразно, поэтому сделала структуру ответа.